---
layout: post
title: "Java中的IO流"
date: 2019-10-18
tag: io流
description: "Java中的IO流"

---

------

<div align="center">
	<img src="/images/posts/IO流//io流继承关系.jpg" />  
</div> 

# **字节流**

## **InputStream**

​		此**抽象类**是表示字节输入流的所有类的超类。

### **FileInputStream**

#### **常用构造方法**

##### **public FileInputStream(File file)**

​		通过打开一个到实际文件的连接来创建一个 FileInputStream，该文件通过文件系统中的 File 对象 file 指定。创建一个新 FileDescriptor 对象来表示此文件连接。

​		file - 为了进行读取而打开的文件。

​		首先，如果有安全管理器，则用 file 参数表示的路径作为参数调用其 checkRead 方法。

​		如果指定文件不存在，或者它是一个目录，而不是一个常规文件，抑或因为其他某些原因而无法打开进行读取，则抛出 FileNotFoundException。

```java
public FileInputStream(File file) throws FileNotFoundException {
    String name = (file != null ? file.getPath() : null);
    SecurityManager security = System.getSecurityManager();
    if (security != null) {
        security.checkRead(name);
    }
    if (name == null) {
        throw new NullPointerException();
    }
    if (file.isInvalid()) {
        throw new FileNotFoundException("Invalid file path");
    }
    fd = new FileDescriptor();
    fd.attach(this);
    path = name;
    open(name);
}
```


##### **public FileInputStream(String name)**

​		通过打开一个到实际文件的连接来创建一个 FileInputStream，该文件通过文件系统中的路径名 name 指定。创建一个新 FileDescriptor 对象来表示此文件连接。

​		name - 与系统有关的文件名。

​		首先，如果有安全管理器，则用 name 作为参数调用其 checkRead 方法。

​		如果指定文件不存在，或者它是一个目录，而不是一个常规文件，抑或因为其他某些原因而无法打开进行读取，则抛出 FileNotFoundException。

```java
public FileInputStream(String name) throws FileNotFoundException {
    //调用构造方法FileInputStream(File file)
    this(name != null ? new File(name) : null);
}
```


#### **常用方法**

##### **public int read()**

​		从此输入流中读取一个数据字节。如果没有输入可用，则此方法将阻塞。

​		该方法返回下一个数据字节；如果已到达文件末尾，则返回 -1。

```java
	FileInputStream fis = new FileInputStream(new File("text.txt"));
	int c = 0;
	while((c = fis.read()) != -1) {
		System.out.print((char)c);
	}
	fis.close();
```


##### **public int read(byte[] b)**

​		从此输入流中将最多 b.length 个字节的数据读入一个字节数组中。在某些输入可用之前，此方法将阻塞。

​		b - 存储读取数据的缓冲区。

​		该方法返回读入缓冲区的字节总数，如果因为已经到达文件末尾而没有更多的数据，则返回 -1。

```java
	FileInputStream fis = new FileInputStream(new File("text.txt"));
	byte[] b = new byte[1024];
	while(fis.read(b) != -1){
		System.out.print(new String(b));
	}
	fis.close();
	//read(b)由read(byte[] b,int off,int len)方法实现
	public int read(byte b[]) throws IOException {
        return readBytes(b, 0, b.length);
    }
```


##### **public int read(byte[] b,int off,int len)**

​		从此输入流中将最多 len 个字节的数据读入一个字节数组中。在某些输入可用之前，此方法将阻塞。

​		b - 存储读取数据的缓冲区。

​		off - 数据的起始偏移量。

​		len - 读取的最大字节数。

```java
	FileInputStream fis = new FileInputStream(new File("text.txt"));
	byte[] b = new byte[10];
	while(fis.read(b,0,5) != -1){
		System.out.print(new String(b));
	}
	fis.close();
	//输出 01234     56789     
	//注：text.txt内容为：0123456789
```
​		根据输出结果和几次测试，我个人总结为：b为读取数据的缓冲区，用于存放fis读取的数；len为每次读取文件的文件指针移动距离，即每次读取多少长度的数据；off为b中数据数据存入的起始位置，即数据存入数组时的起始下标。如上述案例所示，byte数组长度为10，fis.read(b,0,5) 则表示每次从文本中读取len（即5）个长度的数据（即01234），从下标为0的位置开始放入数据（即b：[0,1,2,3,4, , , , , , ]；如果off的值为5，则b：[ , , , , ,0,1,2,3,4]；**如果off+len>b.length，则会造成数组越界异常**，因为此时数组中起始之后的剩余位置已经不够存放读取的数据）。

------



### BufferedInputStream

​		作为另一种输入流，BufferedInputStream 为添加了功能，即缓冲输入和支持 mark 和 reset 方法的能力。创建 BufferedInputStream 时即创建了一个内部缓冲区数组。读取或跳过流中的各字节时，必要时可根据所包含的输入流再次填充该内部缓冲区，一次填充多个字节。mark 操作记录输入流中的某个点，reset 操作导致在从所包含的输入流中获取新的字节前，再次读取自最后一次 mark 操作以来所读取的所有字节。

​		protected  byte[] buf - 存储数据的内部缓冲区数组。

​		protected  int count - 比缓冲区中最后一个有效字节的索引大一的索引。

​		protected  int marklimit - 调用 mark 方法后，在后续调用 reset 方法失败前所允许的最大提前读取量。

​		protected  int markpos - 最后一次调用 mark 方法时 pos 字段的值。

​		protected  int pos - 缓冲区中的当前位置。

#### 常用构造方法

##### public BufferedInputStream(InputStream in)

​		创建 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。创建一个内部缓冲区数组并将其存储在 buf 中。

​		in - 基础输入流。

```java
public BufferedInputStream(InputStream in) {
    this(in, DEFAULT_BUFFER_SIZE);
    //调用BufferedInputStream(InputStream in,int size)构造方法，并设置size为8192
}
```
##### public BufferedInputStream(InputStream in,int size)

​		创建具有指定缓冲区大小的 BufferedInputStream，并保存其参数，即输入流 in，以便将来使用。创建一个长度为 size 的内部缓冲区数组并将其存储在 buf 中。

​		in - 基础输入流。
​		size - 缓冲区的大小。

```java
public BufferedInputStream(InputStream in, int size) {
    super(in);
    if (size <= 0) {
        throw new IllegalArgumentException("Buffer size <= 0");
    }
    buf = new byte[size];
}
```
#### 常用方法

##### public int read()

​		参见 InputStream 的 read 方法的常规协定。用法应该与InputStream的read()方法相同。

##### public int read(byte[] b,int off,int len)

​		在此字节输入流中从给定的偏移量开始将各字节读取到指定的 byte 数组中。 

​		此方法实现了相应 InputStream 类的 read 方法的常规协定。另一个便捷之处在于，它会尝试尽可能多的读取字节，方法是重复地调用基础流的 read 方法。这种迭代的 read 会一直继续下去，直到满足下列某个条件： 

- 已经读取了指定的字节数，

- 基础流的 read 方法返回 -1，指示文件末尾（end-of-file），或者

- 基础流的 available 方法返回零，指示将阻塞进一步的输入请求。

​		如果在基础流上第一次调用 read 返回 -1（指示文件末尾），则此方法返回 -1。否则此方法返回实际读取的字节数。 

​		鼓励（但不是必须）此类的各个子类以相同的方式尝试读取尽可能多的字节。

​		该方法覆盖了FileInputStream中的read方法，返回读取的字节数，如果已到达流末尾，则返回 -1。



OutputStream



FileOutputStream



BufferedOutputStream



字符流




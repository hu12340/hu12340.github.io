---
layout: post
title: "Java多线程"
date: 2019-11-01 
description: "Java多线程"
tag: 多线程 
---

------

**线程和进程的区别总结：**

1.  进程是一段正在执行的程序，是资源分配的基本单元，而线程是CPU调度的基本单元。
2.  进程间相互独立、不能共享资源，一个进程至少有一个线程，同一进程的各线程共享整个进程的资源（寄存器、堆栈、上下文）。
3.  线程的创建和切换开销比进程小。

------

**public class Thread extends Object implements Runnable**

​		线程是程序中执行的线程。 Java虚拟机允许应用程序同时执行多个执行线程。

​		每个线程都有优先权。 具有较高优先级的线程优先于优先级较低的线程执行。 每个线程可能也可能不会被标记为守护程序。 当在一些线程中运行的代码创建一个新的Thread对象时，新线程的优先级最初设置为等于创建线程的优先级，并且当且仅当创建线程是守护进程时才是守护线程。

​		创建一个新的执行线程有两种方法：继承Thread类和实现Runnable接口。

```java
//创建Thread对象并重写run方法
new Thread() {
    @Override
    public void run() {
        System.out.println("第一个线程执行...");
    }
}.start();
//创建Thread对象并传入一个实现Runnable接口的匿名内部类
new Thread(new Runnable() {
    @Override
    public void run() {
        System.out.println("第二个线程执行...");
    }
}).start();
```

执行结果：

![](D:\MyBlog\hu12340.github.io\images\posts\Java多线程\QQ图片20191104171258.png)

------

**线程状态**

线程状态 Thread.State。 线程可以处于以下状态之一：

**NEW**

​		线程尚未启动的线程状态。线程创建未调用start方法前，就为NEW状态。

**RUNNABLE**

​		可运行线程的线程状态。 可运行状态的线程正在Java虚拟机中执行，但它可能正在等待来自操作系统（例如处理器）的其他资源。

**BLOCKED**

​		一个线程的线程状态阻塞**等待监视器锁定**。 处于阻塞状态的线程正在等待监视器锁定进入同步块/方法，或者在调用Object.wait后重新输入同步的块/方法。

**WAITING**

等待线程的线程状态 由于调用以下方法之一，线程处于等待状态： 

-   不带超时值的 Object.wait 

-   不带超时值的 Thread.join 

-   LockSupport.park 

​		处于等待状态的线程正等待另一个线程，以执行特定操作。 例如，已经在某一对象上调用了 Object.wait() 的线程正等待另一个线程，以便在该对象上调用 Object.notify() 或 Object.notifyAll()。已经调用了 Thread.join() 的线程正在等待指定线程终止。

**TIMED_WAITING**

具有指定等待时间的等待线程的线程状态。 线程处于定时等待状态，因为在指定的正等待时间内调用以下方法之一：

-   Thread.sleep 
-   带有超时值的 Object.wait 
-   带有超时值的 Thread.join 
-   LockSupport.parkNanos 
-   LockSupport.parkUntil 

**TERMINATED**

​		终止线程的线程状态。 线程已完成执行。 

![](D:\MyBlog\hu12340.github.io\images\posts\Java多线程\4840092-f85e70e2262b7878.png)

------

**常用方法**

**public void start()**

​		使该线程开始执行；Java 虚拟机调用该线程的 run 方法。

**public long getId()**

​		返回该线程的标识符。线程 ID 是一个正的 long 数，在创建该线程时生成。线程 ID 是惟一的，并终生不变。线程终止时，该线程 ID 可以被重新使用。

**public final String getName()**

​		返回该线程的名称。

**public final int getPriority()**

​		返回线程的优先级。

**public Thread.State getState()**

​		返回该线程的状态。 该方法用于监视系统状态，不用于同步控制。

**public final ThreadGroup getThreadGroup()**

​		返回该线程所属的线程组。 如果该线程已经终止（停止运行），该方法则返回 null。

**public static Thread currentThread()**

​		返回对当前**正在执行的线程**对象的引用。

​		可配合着其他方法一起使用，如：

```java
new Thread() {
    @Override
    public void run() {
        System.out.println("获取线程名：" + Thread.currentThread().getName());
        System.out.println("获取Id：" + Thread.currentThread().getId());
        System.out.println("获取优先级：" + Thread.currentThread().getPriority());
        System.out.println("获取线程状态：" + Thread.currentThread().getState());
    }
}.start();
```

执行结果如下：

![](D:\MyBlog\hu12340.github.io\images\posts\Java多线程\QQ图片20191104172552.png)

**public void interrupt()**

​		中断线程。所谓的中断线程，其实只是在该线程上加了一个中断标志，**并不会使该线程停止或暂停执行**。**被中断的线程还是会继续执行**，这时可以通过调用interrupted或isInterrupted方法对该线程进行需要的操作处理。

​		如果当前线程没有中断它自己（这在任何情况下都是允许的），则该线程的 checkAccess 方法就会被调用，这可能抛出 SecurityException。 

​		如果线程在调用 Object 类的 wait()、wait(long) 或 wait(long, int) 方法，或者该类的 join()、join(long)、join(long, int)、sleep(long) 或 sleep(long, int) 方法过程中受阻，则其中断状态将被清除，它还将收到一个 InterruptedException。

​		如果该线程在可中断的通道上的 I/O 操作中受阻，则该通道将被关闭，该线程的中断状态将被设置并且该线程将收到一个 ClosedByInterruptException。

​		如果该线程在一个 Selector 中受阻，则该线程的中断状态将被设置，它将立即从选择操作返回，并可能带有一个非零值，就好像调用了选择器的 wakeup 方法一样。

​		如果以前的条件都没有保存，则该线程的中断状态将被设置。

**public static boolean interrupted()**

​		如果当前线程已经中断，则返回 true；否则返回 false。

​		测试当前线程是否已经中断。线程的中断状态由该方法清除（**该方法会清除该线程的中断状态**，即撤销该线程的中断标志，成为未中断状态）。换句话说，如果连续两次调用该方法，则第二次调用将返回 false（在第一次调用已清除了其中断状态之后，且第二次调用检验完中断状态前，当前线程再次中断的情况除外）。

**public boolean isInterrupted()**

​		如果该线程已经中断，则返回 true；否则返回 false。

​		测试线程是否已经中断。线程的中断状态 不受该方法的影响（**不会清除该线程的中断状态**）。

------

```java
public void run() {
    //线程并未中断
    System.out.println("isInterrupted:" + Thread.currentThread().isInterrupted());
    //中断线程
    Thread.currentThread().interrupt();
    //线程中断后并不会死亡，此时线程状态为RUNNABLE
    System.out.println("getState:" + Thread.currentThread().getState());
    //线程中断后isInterrupted为true
    System.out.println("isInterrupted:" + Thread.currentThread().isInterrupted());
    //此时线程已经中断，调用interrupted返回true 并且清除线程的中断状态
    System.out.println("interrupted:" + Thread.interrupted());
    //线程中断状态已经被interrupted方法清除，所以此时isInterrupted为false
    System.out.println("isInterrupted:" + Thread.currentThread().isInterrupted());
    //线程中断状态已被清除，调用interrupted返回false 并且清除线程的中断状态
    System.out.println("interrupted:" + Thread.interrupted());
    //线程中断状态已经被interrupted方法清除，所以此时isInterrupted为false
    System.out.println("isInterrupted:" + Thread.currentThread().isInterrupted());
}
```

该方法执行结果如下：

![](D:\MyBlog\hu12340.github.io\images\posts\Java多线程\QQ图片20191105165459.png)



​		在网上找线程中断的资料时，发现了一篇写的很详细的博客，在这里推介一下：

​		 [https://www.cnblogs.com/yangming1996/p/7612653.html]( https://www.cnblogs.com/yangming1996/p/7612653.html ) 








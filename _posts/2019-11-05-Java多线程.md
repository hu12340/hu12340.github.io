---
layout: post
title: "Java多线程"
date: 2019-11-01 
description: "Java多线程"
tag: 多线程 
---

------

**线程和进程的区别总结：**

1.  进程是一段正在执行的程序，是资源分配的基本单元，而线程是CPU调度的基本单元。
2.  进程间相互独立、不能共享资源，一个进程至少有一个线程，同一进程的各线程共享整个进程的资源（寄存器、堆栈、上下文）。
3.  线程的创建和切换开销比进程小。

------

**public class Thread extends Object implements Runnable**

​		线程是程序中执行的线程。 Java虚拟机允许应用程序同时执行多个执行线程。

​		每个线程都有优先权。 具有较高优先级的线程优先于优先级较低的线程执行。 每个线程可能也可能不会被标记为守护程序。 当在一些线程中运行的代码创建一个新的Thread对象时，新线程的优先级最初设置为等于创建线程的优先级，并且当且仅当创建线程是守护进程时才是守护线程。

​		创建一个新的执行线程有两种方法：继承Thread类和实现Runnable接口。

```java
//创建Thread对象并重写run方法
new Thread() {
    @Override
    public void run() {
        System.out.println("第一个线程执行...");
    }
}.start();
//创建Thread对象并传入一个实现Runnable接口的匿名内部类
new Thread(new Runnable() {
    @Override
    public void run() {
        System.out.println("第二个线程执行...");
    }
}).start();
```

执行结果：

![](D:\MyBlog\hu12340.github.io\images\posts\Java多线程\QQ图片20191104171258.png)

------

**线程状态**

线程状态。 线程可以处于以下状态之一：

**NEW**

​		线程尚未启动的线程状态。线程创建未调用start方法前，就为NEW状态。

**RUNNABLE**

​		可运行线程的线程状态。 可运行状态的线程正在Java虚拟机中执行，但它可能正在等待来自操作系统（例如处理器）的其他资源。

**BLOCKED**

​		一个线程的线程状态阻塞**等待监视器锁定**。 处于阻塞状态的线程正在等待监视器锁定进入同步块/方法，或者在调用Object.wait后重新输入同步的块/方法。

**WAITING**

等待线程的线程状态 由于调用以下方法之一，线程处于等待状态： 

-   Object.wait且没有设置超时 

-   Thread.join且没有设置超时 

-   LockSupport.park 

​		等待状态的线程正在等待另一个线程执行特定的动作。 例如，一个已调用线程Object.wait()的对象上正在等待另一个线程来调用Object.notify()或Object.notifyAll()该对象上。 一个调用Thread.join()线程正在等待指定的线程终止。

**TIMED_WAITING**

具有指定等待时间的等待线程的线程状态。 线程处于定时等待状态，因为在指定的正等待时间内调用以下方法之一：

-   Thread.sleep 
-   Object.wait且设置了超时 
-   Thread.join且设置了超时 
-   LockSupport.parkNanos 
-   LockSupport.parkUntil 

**TERMINATED**

​		终止线程的线程状态。 线程已完成执行。 

![](D:\MyBlog\hu12340.github.io\images\posts\Java多线程\4840092-f85e70e2262b7878.png)

------

**常用方法**

**public void start()**

​		使该线程开始执行；Java 虚拟机调用该线程的 run 方法。



------

**public static Thread currentThread()**

​		返回对当前**正在执行的线程**对象的引用。

​		可配合着其他方法一起使用，如：

```java
new Thread() {
    @Override
    public void run() {
        System.out.println("获取线程名：" + Thread.currentThread().getName());
        System.out.println("获取Id：" + Thread.currentThread().getId());
        System.out.println("获取优先级：" + Thread.currentThread().getPriority());
        System.out.println("获取线程状态：" + Thread.currentThread().getState());
    }
}.start();
```

执行结果如下：

![](D:\MyBlog\hu12340.github.io\images\posts\Java多线程\QQ图片20191104172552.png)

------


















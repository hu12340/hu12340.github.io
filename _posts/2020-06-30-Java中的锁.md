---
layout: post
title: "Java中的锁"
date: 2020-06-30 
description: "Java中的锁"
tag: 锁 
---

------

# Java中的锁

​		Java中有很多锁名词：自旋锁 ，自适应自旋锁，阻塞锁，可重入锁 ，读写锁 ，互斥锁 ，悲观锁 ，乐观锁 ，公平锁，非公平锁 ，偏向锁，线程锁，锁粗化， 锁消除，轻量级锁，重量级锁，独享锁，共享锁，分段锁。

## 乐观锁/悲观锁

​		乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。这里的乐观和悲观都是相对于并发而言的。

​		悲观锁认为对于同一个数据的并发操作，一定会被其它线程修改，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。

​		乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。

​		悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。悲观锁在Java中的使用，就是利用各种锁。乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。

## 公平锁/非公平锁

​		公平锁是指多个线程按照申请锁的顺序来获取锁。非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。

​		如有一个锁资源已经被获取，多个线程在等待该锁资源的释放；这时又有某个线程尝试获取这个锁资源，刚好拥有该锁资源的线程执行完毕。在非公平锁中，该线程则会直接获取到锁资源，避免了去唤醒线程的开销；而在公平锁中，则会在阻塞队列中去按顺序唤醒等待的线程，新来的线程会添加到阻塞队列。

## 独享锁/共享锁

​		独享锁是指该锁一次只能被一个线程所持有。共享锁是指该锁可被多个线程所持有。

​		ReentrantReadWriteLock，其读锁是共享锁，其写锁是独享锁。Synchronized是独享锁。

## 互斥锁/读写锁

​		独享锁/共享锁是一种广义的说法，互斥锁/读写锁就是具体的实现。互斥锁在Java中的具体实现就是ReentrantLock，读写锁在Java中的具体实现就是ReentrantReadWriteLock。

## 自旋锁

​		指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁。好处是减少线程上下文切换的消耗，避免线程切换的开销。缺点是循环会消耗CPU。

​		如果锁被占用的时间很短，自旋等待的效果就会非常好，反之，如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源，而不会做任何有用的工作，反而会带来性能上的浪费。

​		JDK1.4.2自旋锁默认是关闭的,可以使用-XX:+UseSpinning参数来开启，JDK1.6默认已经开启，自旋锁等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的。如果自旋锁超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程了，自旋次数的默认是10次，用户可以使用参数-XX:PreBlockSpin=10修改。

## 自适应自旋锁

​		在JDK 1.6中引入了自适应的自旋锁。自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。

- 如果在同一个锁对象上，**自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功**，进而它将允许自旋等待持续相对更长时间。
- 如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。

## 阻塞锁

​		让线程进入阻塞状态进行等待，当获得相应的信号（唤醒，时间） 时，才可以进入线程的准备就绪状态，准备就绪状态的所有线程，通过竞争，进入运行状态。

​		JAVA中，能够进入\退出、阻塞状态或包含阻塞锁的方法有 ，synchronized 关键字（其中的重量锁），ReentrantLock，Object.wait()\notify(),LockSupport.park()/unpart()(j.u.c经常使用)。

​		阻塞锁的优势在于，阻塞的线程不会占用cpu时间， 不会导致 CPU占用率过高，但进入时间以及恢复时间都要比自旋锁略慢。在线程竞争不激烈的情况下，使用自旋锁，竞争激烈的情况下使用，阻塞锁。

## 可重入锁

​		可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。可重入锁可防止自身在获取到某个锁资源时再次尝试去获取该锁资源而造成死锁的状况。

​		ReentrantLock中使用了state变量来实现可重入锁：当某个线程在获取到某个锁资源时，会将AQS中的state值从0变为1；若该线程再次获取这个锁资源，则会将state值加1，释放时则减1；当state值重新变为0时，表示释放了锁资源。

​		Synchronize则是使用对象Monitor中的count值来记录重入次数。

## 锁优化

​		高效并发是从JDK 1.5到JDK 1.6的一个重要改进，HotSpot虚拟机开发团队在这个版本上花费了大量的精力去实现各种锁优化技术，如适应性自旋（Adaptive Spinning）、锁消除（Lock Elimination）、锁粗化（Lock Coarsening）、轻量级锁（Lightweight Locking）和偏向锁。

## 锁消除

​		锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。

​		锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断在一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行。

## 锁粗化

​		原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小——只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待锁的线程也能尽快拿到锁。

​		大部分情况下，上面的原则都是正确的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。

## 偏向锁

​		偏向锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。

<div align="center">
	<img src="/images/posts/Java中的锁/锁标志.png" />  
</div> 

​		当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为“01”，即偏向模式。同时使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word之中，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作。

​		当有另外一个线程去尝试获取这个锁时，偏向模式就宣告结束。根据锁对象目前是否处于被锁定的状态，撤销偏向（Revoke Bias）后恢复到未锁定（标志位为“01”）或轻量级锁定（标志位为“00”）的状态。

> 偏向锁可以提高带有同步但无竞争的程序性能。它同样是一个带有效益权衡（TradeOff）性质的优化，也就是说，它并不一定总是对程序运行有利，如果程序中大多数的锁总是被多个不同的线程访问，那偏向模式就是多余的。

## 轻量级锁

​		轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量。轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。

​		代码进入同步块的时候，如果此同步对象没有被锁定（锁标志位为“01”状态），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的MarkWord的拷贝（官方把这份拷贝加了一个Displaced前缀，即Displaced Mark Word）。然后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针。如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位（Mark Word的最后2bit）将转变为“00”，即表示此对象处于轻量级锁定状态。如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程抢占了。

​		如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。

## 分段锁

​		分段锁其实是一种锁的设计，并不是具体的一种锁。分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。

> ​		对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。ConcurrentHashMap中的分段锁称为Segment，它即类似于HashMap（JDK7与JDK8中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock)。
>
> ​		当需要put元素的时候，并不是对整个hashmap进行加锁，而是**先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁**，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。
>
> ​		但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计。分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。
